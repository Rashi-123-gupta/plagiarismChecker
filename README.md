# Приложение по поиску плагиата с использованием PostgreSQL

---

![Gif](https://github.com/Vya4eslavSeleznev/PlagiarismChecker/blob/master/docs/plagiarismChecker.gif)

---

Данный проект представляет собой клиент-серверное приложение, которое общается по протоколу HTTPS. Сервис реализован при помощь веб-фреймворка flask.  
Серверная часть приложения состоит из нескольких модулей: обработка файла, загрузка в базу данных и передача содержимого классу Engine. Добавить данные в базу PostgreSQL можно при помощи файла .docx. Извлекается содержимое из документа и вставляется в БД.  
Клиентская же часть имеет в своем составе следующие страницы: авторизация, регистрация, аккаунты для администратора и пользователя. Более того, все было развернуто с использованием связки — двух серверов Nginx и Gunicorn. Как приложение, так и серверы были контейнеризированы при помощи Docker для того, чтобы использовать все локально на компьютере.  

![Project](/docs/project.png)

---

### Backend

###### Engine
Сердцем проекта является класс Engine. Именно данный модуль осуществляет всю сложную работу — поиск заимствований. Основными инструментами, благодаря которым осуществляется все работа, являются BERT и FAISS. Рекомендованное использование нейронной сети BERT — дообучение на конкретной задаче. Однако решение, должно быть способно работать в большинстве предметных областях. Из этого следует, что необходимо выбрать универсальный вариант. В связи с этим была использована предобученная модель на корпусе текстов Википедии, которая способна распознавать 104 языка. Все это позволяет распознавать не только слова, но и смысл предложений. Чтобы эффективно работать с большим объемом данных используется FAISS. Как происходит формирование результатов?  
За итоговые показатели по заимствованию отвечает блок «Формирование результатов». В момент, когда FAISS выполнил свою задачу, он возвращает номера самых похожих элементов. Количество результатов задает сам пользователь. Также стоит отметить, что все элементы, в том числе полученные, закодированы.  
Теперь стадия расчета плагиата: для этого была использована метрика косинуса. Используется два вектора: входящий, который пользователь отправляет на проверку, и вектор, который выдала библиотека FAISS. После этого вычисляется косинус угла между ними, полученное значение меньше единицы. Результат умножается на 100 и получается процент заимствований. Например, косинус 90 градусов равен 0. Это означает, что два вектора имеют нулевую схожесть.  

![Engine](/docs/engine.png)

Класс Parser необходим для обработки входных документов с разрешением .docx. Разработанный алгоритм позволяет на выходе получать единый текст, без символов новой строки, красной строки — знаков табуляции. Более того, в финальный результат не попадают картинки и таблицы. По итогу подготовленные параграфы объединяются в один. После таких манипуляций текст будет готов к кодированию. В качестве библиотеки на языке Python была выбрана «docx», так как в ней есть все доступные методы, позволяющие реализовать парсер файлов.

![Parser](/docs/parser.png)

---

### Frontend

В роли инструмента для разработки фронтэнда был выбран Vanilla JavaScript. Это обычный JavaScript без каких-либо дополнительных библиотек или фреймворков. Vanilla JS не нуждается в каких-то внешних ресурсах, поэтому выполнение кода Vanilla JS происходит на стороне клиента, что делает его скорость превосходной. Еще одним достоинством для разработчиков является тот факт, что Vanilla JS это довольно простой инструмент для разработки. Помогает лучше познать основы JS, чтобы иметь возможность быстрее освоить использование новых фреймворков.  
В приложении по распознаванию плагиата фон был сделан динамическим, благодаря Particles.js. Это библиотека JavaScript, которая создает большие наборы различных частиц, состоящих из точек и отрезков. Как правило, они движутся, а также соединены и образуют полигоны. Более того, пользователь может с ними взаимодействовать с использованием мыши компьютера. Появление курсора вне области, которая предназначена для ввода и использования информации, разгоняет частицы и очищает их на заднем фоне. Чтобы воспользоваться данной функцией, необходимо обратиться к функции JS — particlesJS. В нее необходимо поместить конфигурационный объект в формате JSON, который и будет описывать поведение частиц.  

- При запуске приложения пользователь попадает на главную страницу авторизации. Предоставляется возможность идентифицироваться — ввести свою информацию: логин и пароль. После этого можно нажать на кнопку «Sign in» и загрузится профиль клиента:

![Auth](/docs/auth.png)

- Страница регистрации создавалось с целью добавления нового пользователя в таблицу «Customer». Для этого нужно ввести в три текстовые поля свои персональные данные: имя, логин и пароль:

![Reg](/docs/reg.png)

- При успешном входе в систему пользователь видит свой аккаунт. Сперва ему доступно: выбор файла с расширением .docx — кнопка «Choose File», подбор числа результатов с помощью ползунка (значение может варьироваться от 1 до 10):

![User acc1](/docs/userAcc1.png)

- После того, как все действия выполнены успешно клиент нажимает на кнопку «Submit» и появляется таблица с результатами. В ней расположены две колонки: название файла и рассчитанный результат:

![User acc2](/docs/userAcc2.png)

- При входе в систему под ролью администратора, сразу же загружается таблица из PostgreSQL с полями: название файла и его содержание:

![Admin acc1](/docs/adminAcc1.png)



